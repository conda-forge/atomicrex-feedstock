From c71a665ef6712ea598e585e46b9193a3f043eaf3 Mon Sep 17 00:00:00 2001
From: Jan Janssen <janssen@mpie.de>
Date: Thu, 19 Oct 2023 14:42:45 +0200
Subject: [PATCH] fix python bindings

---
 src/python/PythonBinding.h | 153 +++++++++++++++++++------------------
 1 file changed, 78 insertions(+), 75 deletions(-)

diff --git a/src/python/PythonBinding.h b/src/python/PythonBinding.h
index ed273a1..573bb77 100644
--- a/src/python/PythonBinding.h
+++ b/src/python/PythonBinding.h
@@ -30,92 +30,95 @@
 #include <arexlib/Atomicrex.h>
 
 /// Helper template function that creates the binding for a getter method returning a matrix.
-template<typename ParentClass, typename MatrixClass, const MatrixClass& (ParentClass::*getter_func)() const>
-pybind11::cpp_function MatrixGetter() 
+template <typename ParentClass, typename MatrixClass, const MatrixClass& (ParentClass::*getter_func)() const>
+pybind11::cpp_function MatrixGetter()
 {
-	return pybind11::cpp_function([](pybind11::object& obj) {
-		const MatrixClass& tm = (obj.cast<ParentClass&>().*getter_func)();
-		pybind11::array_t<typename MatrixClass::element_type> array({ tm.row_count(), tm.col_count() }, 
-				{ sizeof(typename MatrixClass::element_type), sizeof(typename MatrixClass::column_type) }, 
-				tm.elements(), obj);
-		// Mark array as read-only.
-		reinterpret_cast<pybind11::detail::PyArray_Proxy*>(array.ptr())->flags &= ~pybind11::detail::npy_api::NPY_ARRAY_WRITEABLE_;
-		return array;
-	});
+    return pybind11::cpp_function([](pybind11::object& obj) {
+        const MatrixClass& tm = (obj.cast<ParentClass&>().*getter_func)();
+        pybind11::array_t<typename MatrixClass::element_type> array(
+            {tm.row_count(), tm.col_count()},
+            {sizeof(typename MatrixClass::element_type), sizeof(typename MatrixClass::column_type)}, tm.elements(), obj);
+        // Mark array as read-only.
+        reinterpret_cast<pybind11::detail::PyArray_Proxy*>(array.ptr())->flags &=
+            ~pybind11::detail::npy_api::NPY_ARRAY_WRITEABLE_;
+        return array;
+    });
 }
 
-NAMESPACE_BEGIN(pybind11)
-NAMESPACE_BEGIN(detail)
+PYBIND11_NAMESPACE_BEGIN(pybind11)
+PYBIND11_NAMESPACE_BEGIN(detail)
 
-	/// Automatic Python <--> Vector3 conversion
-    template<typename T> struct type_caster<atomicrex::Vector_3<T>> {
-    public:
-        bool load(handle src, bool) {
-			if(!isinstance<sequence>(src)) return false;
-			sequence seq = reinterpret_borrow<sequence>(src);
-			if(seq.size() != value.size())
-				throw value_error("Expected sequence of length 3.");
-			for(size_t i = 0; i < value.size(); i++)
-				value[i] = seq[i].cast<T>();
-			return true;
-        }
+/// Automatic Python <--> Vector3 conversion
+template <typename T>
+struct type_caster<atomicrex::Vector_3<T>> {
+public:
+    bool load(handle src, bool)
+    {
+        if(!isinstance<sequence>(src)) return false;
+        sequence seq = reinterpret_borrow<sequence>(src);
+        if(seq.size() != value.size()) throw value_error("Expected sequence of length 3.");
+        for(size_t i = 0; i < value.size(); i++) value[i] = seq[i].cast<T>();
+        return true;
+    }
 
-        static handle cast(const atomicrex::Vector_3<T>& src, return_value_policy /* policy */, handle /* parent */) {
-			return pybind11::make_tuple(src[0], src[1], src[2]).release();
-        }
+    static handle cast(const atomicrex::Vector_3<T>& src, return_value_policy /* policy */, handle /* parent */)
+    {
+        return pybind11::make_tuple(src[0], src[1], src[2]).release();
+    }
 
-		PYBIND11_TYPE_CASTER(atomicrex::Vector_3<T>, _("Vector3<") + make_caster<T>::name() + _(">"));
-    };	
+    PYBIND11_TYPE_CASTER(atomicrex::Vector_3<T>, _("Vector3<") + make_caster<T>::name() + _(">"));
+};
 
-	/// Automatic Python <--> Point3 conversion
-    template<typename T> struct type_caster<atomicrex::Point_3<T>> {
-    public:
-        bool load(handle src, bool) {
-			if(!isinstance<sequence>(src)) return false;
-			sequence seq = reinterpret_borrow<sequence>(src);
-			if(seq.size() != value.size())
-				throw value_error("Expected sequence of length 3.");
-			for(size_t i = 0; i < value.size(); i++)
-				value[i] = seq[i].cast<T>();
-			return true;
-        }
+/// Automatic Python <--> Point3 conversion
+template <typename T>
+struct type_caster<atomicrex::Point_3<T>> {
+public:
+    bool load(handle src, bool)
+    {
+        if(!isinstance<sequence>(src)) return false;
+        sequence seq = reinterpret_borrow<sequence>(src);
+        if(seq.size() != value.size()) throw value_error("Expected sequence of length 3.");
+        for(size_t i = 0; i < value.size(); i++) value[i] = seq[i].cast<T>();
+        return true;
+    }
 
-        static handle cast(const atomicrex::Point_3<T>& src, return_value_policy /* policy */, handle /* parent */) {
-			return pybind11::make_tuple(src[0], src[1], src[2]).release();
-        }
+    static handle cast(const atomicrex::Point_3<T>& src, return_value_policy /* policy */, handle /* parent */)
+    {
+        return pybind11::make_tuple(src[0], src[1], src[2]).release();
+    }
 
-		PYBIND11_TYPE_CASTER(atomicrex::Point_3<T>, _("Point3<") + make_caster<T>::name() + _(">"));
-    };		
+    PYBIND11_TYPE_CASTER(atomicrex::Point_3<T>, _("Point3<") + make_caster<T>::name + _(">"));
+};
 
-	/// Automatic Python <--> Matrix3 conversion
-    template<typename T> struct type_caster<atomicrex::Matrix_3<T>> {
-    public:
-        bool load(handle src, bool) {
-			if(!isinstance<sequence>(src)) return false;
-			sequence seq1 = reinterpret_borrow<sequence>(src);
-			if(seq1.size() != value.row_count())
-				throw value_error("Expected sequence of length 3.");
-			for(size_t i = 0; i < value.row_count(); i++) {
-				if(!isinstance<sequence>(seq1[i])) 
-					throw value_error("Expected nested sequence of length 3.");
-				sequence seq2 = reinterpret_borrow<sequence>(seq1[i]);
-				if(seq2.size() != value.col_count())
-					throw value_error("Expected nested sequence of length 3.");
-				for(size_t j = 0; j < value.col_count(); j++) {
-					value(i,j) = seq2[j].cast<T>();
-				}
-			}
-			return true;
+/// Automatic Python <--> Matrix3 conversion
+template <typename T>
+struct type_caster<atomicrex::Matrix_3<T>> {
+public:
+    bool load(handle src, bool)
+    {
+        if(!isinstance<sequence>(src)) return false;
+        sequence seq1 = reinterpret_borrow<sequence>(src);
+        if(seq1.size() != value.row_count()) throw value_error("Expected sequence of length 3.");
+        for(size_t i = 0; i < value.row_count(); i++) {
+            if(!isinstance<sequence>(seq1[i])) throw value_error("Expected nested sequence of length 3.");
+            sequence seq2 = reinterpret_borrow<sequence>(seq1[i]);
+            if(seq2.size() != value.col_count()) throw value_error("Expected nested sequence of length 3.");
+            for(size_t j = 0; j < value.col_count(); j++) {
+                value(i, j) = seq2[j].cast<T>();
+            }
         }
+        return true;
+    }
 
-        static handle cast(const atomicrex::Matrix_3<T>& src, return_value_policy /* policy */, handle /* parent */) {
-			return pybind11::array_t<T>({ src.row_count(), src.col_count() }, 
-				{ sizeof(T), sizeof(typename atomicrex::Matrix_3<T>::column_type) }, 
-				src.elements()).release();
-        }
+    static handle cast(const atomicrex::Matrix_3<T>& src, return_value_policy /* policy */, handle /* parent */)
+    {
+        return pybind11::array_t<T>({src.row_count(), src.col_count()},
+                                    {sizeof(T), sizeof(typename atomicrex::Matrix_3<T>::column_type)}, src.elements())
+            .release();
+    }
 
-		PYBIND11_TYPE_CASTER(atomicrex::Matrix_3<T>, _("Matrix3<") + make_caster<T>::name() + _(">"));
-    };
+    PYBIND11_TYPE_CASTER(atomicrex::Matrix_3<T>, _("Matrix3<") + make_caster<T>::name + _(">"));
+};
 
-NAMESPACE_END(detail)
-NAMESPACE_END(pybind11)
+PYBIND11_NAMESPACE_END(detail)
+PYBIND11_NAMESPACE_END(pybind11)
